>>>> AGENTS.md
See /CONTRIBUTING.md for guidelines on codestyle.

>>>> CLAUDE.md
See /CONTRIBUTING.md for guidelines on codestyle.

>>>> CONTRIBUTING.md
# Contributing

## TL;DR

Install [uv](https://docs.astral.sh/uv/).
Clone this repository, then from the root directory:

```sh
uv run python  # TODO
```

You also need [yek](https://github.com/bodo-run/yek) for generating docs.

## Coding Style & Conventions

* Don't hard-wrap comments. Only use linebreaks for new paragraphs. Let the editor soft wrap content.
* Use single-backticks for variables. We use Markdown and [pdoc3](https://pdoc3.github.io/pdoc/) for docs rather than ReST and Sphinx.
* File descriptors from `open()` are called `fd`.
* Use types where possible, including `jaxtyping` hints.
* Decorate functions with `beartype.beartype` unless they use a `jaxtyping` hint, in which case use `jaxtyped(typechecker=beartype.beartype)`.
* Variables referring to a filepath should be suffixed with `_fpath`. Directories are `_dpath`.
* Prefer `make` over `build` when naming functions that construct objects, and use `get` when constructing primitives (like string paths or config values).
* Only use `setup` for naming functions that don't return anything.

Throughout the code, variables are annotated with shape suffixes, as [recommended by Noam Shazeer](https://medium.com/@NoamShazeer/shape-suffixes-good-coding-style-f836e72e24fd).

The key for these suffixes:

* B: batch size
* W: width in patches (typically 14 or 16)
* H: height in patches (typically 14 or 16)
* D: ViT activation dimension (typically 768 or 1024)
* S: SAE latent dimension (768 x 16, etc)
* L: Number of latents being manipulated at once (typically 1-5 at a time)
* C: Number of classes in ADE20K (151)

For example, an activation tensor with shape (batch, width, height d_vit) is `acts_BWHD`.

## Testing & Linting

`justfile` contains commands for testing and linting.

`just lint` will format and lint.
`just test` will format, lint and test, then report coverage.

## Commit / PR Checklist

1. Run `just test`.
2. Check that there are no regressions. Unless you are certain tests are not needed, the coverage % should either stay the same or increase.
3. Run `just docs`.
4. Fix any missing doc links.

>>>> README.md
# vcell

This is the repo for a [virtual cell challenge](https://virtualcellchallenge.org) submission.

To install, clone this repository (via SSH is probably easier, but you do you).

In the project root directory, run `uv run python`. The first invocation should create a virtual environment.

## Setup

**Editor:**
I would add `docs/api/` to whatever `.ignore`-like system you have so that they don't show up.
We commit them to git so that they can be browsed on GitHub, but you don't want to edit them by hand because they are generated by [pdoc3](https://pdoc3.github.io/pdoc/).

**Dependencies:** [uv](https://docs.astral.sh/uv/) is the new dependency manager in Python.
There's a short blog post [here](https://samuelstevens.me/writing/uv) describing uv but it's well documented all over the internet.
We use it in this project for the easiest dependency management ever.
Please install it--it's very high quality software.

**Automated Tooling:** [just](https://github.com/casey/just) is a decent language-agnostic replacement for `package.json` scripts.
It supports dependencies and is pretty fast.
It can be installed with brew (`brew install just`) or from a binary because it doesn't really need to be updated frequently.

> I am happy to change to make or another language-agnostic system if we don't want to go with just.

If you run `just --list` in any folder in the repo, it will list all the recipes.
Running `just` without any args will run the first recipe and its dependencies.

When writing new recipes, assume that you are on a generic unix-like system and that the only non-unix tools are `uv` and `just` itself.
So don't use `fd`, `rg`, `npm`, etc.

**AI Tooling (Optional):**
My favorite is [aider](https://aider.chat/).
I won't put a whole tutorial here, but I use Sonnet-3.5 with $20 of API credits loaded up.
The [AGENTS.md](AGENTS.md) file is used by aider so that the coding assistant follows conventions by default.
I symlink CLAUDE.md to AGENTS.md so that Claude Code will read it.

## Data

You need to make an account on [https://virtualcellchallenge.org](https://virtualcellchallenge.org) and then you can download the data.
The data provided by the challenge is 15GB.

## Baseline



## Docs

API docs are generated from Python docstrings using [pdoc3](https://pdoc3.github.io/pdoc/).
You can run `just docs` to generate new API docs in `docs/api`.
To write good docstrings that can be parsed, try to follow the conventions in existing code.

The docs recipe also generates `docs/api/llms.txt` which is all of the API docs in one .txt file.
This is great for copy-pasting into an LLM to ask it how to do something with our codebase.

## Dependencies

I hate dependencies.
I haaaaate dependencies.
That being said, here are some great tools that I use in nearly every project (including this one).

[tyro](https://brentyi.github.io/tyro/) turns functions into Python scripts.
By adding docstrings and types to everything (good practice anyways!) you can get great command-line interfaces to your Python scripts.

[beartype](https://beartype.readthedocs.io/en/stable/) is an "open-source pure-Python PEP-compliant near-real-time hybrid runtime-static third-generation type-checker."
While the docs can be a little corny, it adds very fast runtime type checking to your functions, meaning you never need to write any code that checks for types.
It is a runtime alternative to MyPy for when you have some objects typed `any` that you still want to type-check.
Please decorate every function with it.

>>>> __init__.py

>>>> helpers.py
# src/vcell/helpers.py
import collections.abc
import logging
import pathlib
import subprocess
import time

import beartype


@beartype.beartype
class progress:
    def __init__(self, it, *, every: int = 10, desc: str = "progress", total: int = 0):
        """
        Wraps an iterable with a logger like tqdm but doesn't use any control codes to manipulate a progress bar, which doesn't work well when your output is redirected to a file. Instead, simple logging statements are used, but it includes quality-of-life features like iteration speed and predicted time to finish.

        Args:
            it: Iterable to wrap.
            every: How many iterations between logging progress.
            desc: What to name the logger.
            total: If non-zero, how long the iterable is.
        """
        self.it = it
        self.every = every
        self.logger = logging.getLogger(desc)
        self.total = total

    def __iter__(self):
        start = time.time()

        try:
            total = len(self)
        except TypeError:
            total = None

        for i, obj in enumerate(self.it):
            yield obj

            if (i + 1) % self.every == 0:
                now = time.time()
                duration_s = now - start
                per_min = (i + 1) / (duration_s / 60)

                if total is not None:
                    pred_min = (total - (i + 1)) / per_min
                    self.logger.info(
                        "%d/%d (%.1f%%) | %.1f it/m (expected finish in %.1fm)",
                        i + 1,
                        total,
                        (i + 1) / total * 100,
                        per_min,
                        pred_min,
                    )
                else:
                    self.logger.info("%d/? | %.1f it/m", i + 1, per_min)

    def __len__(self) -> int:
        if self.total > 0:
            return self.total

        # Will throw exception.
        return len(self.it)


@beartype.beartype
class batched_idx:
    """
    Iterate over (start, end) indices for total_size examples, where end - start is at most batch_size.

    Args:
        total_size: total number of examples
        batch_size: maximum distance between the generated indices.

    Returns:
        A generator of (int, int) tuples that can slice up a list or a tensor.
    """

    def __init__(self, total_size: int, batch_size: int):
        """
        Args:
            total_size: total number of examples
            batch_size: maximum distance between the generated indices
        """
        self.total_size = total_size
        self.batch_size = batch_size

    def __iter__(self) -> collections.abc.Iterator[tuple[int, int]]:
        """Yield (start, end) index pairs for batching."""
        for start in range(0, self.total_size, self.batch_size):
            stop = min(start + self.batch_size, self.total_size)
            yield start, stop

    def __len__(self) -> int:
        """Return the number of batches."""
        return (self.total_size + self.batch_size - 1) // self.batch_size


@beartype.beartype
def current_git_commit() -> str | None:
    """
    Best-effort short SHA of the repo containing *this* file.

    Returns `None` when
    * `git` executable is missing,
    * weâ€™re not inside a git repo (e.g. installed wheel),
    * or any git call errors out.
    """
    try:
        # Walk up until we either hit a .git dir or the FS root
        here = pathlib.Path(__file__).resolve()
        for parent in (here, *here.parents):
            if (parent / ".git").exists():
                break
        else:  # no .git found
            return None

        result = subprocess.run(
            ["git", "-C", str(parent), "rev-parse", "--short", "HEAD"],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            check=True,
        )
        return result.stdout.strip() or None
    except (FileNotFoundError, subprocess.CalledProcessError):
        return None

